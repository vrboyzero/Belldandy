import { describe, it, expect } from "vitest";
import { ToolExecutor, DEFAULT_POLICY } from "./executor.js";
// Mock 工具：echo
const echoTool = {
    definition: {
        name: "echo",
        description: "返回输入的消息",
        parameters: {
            type: "object",
            properties: {
                message: { type: "string", description: "要返回的消息" },
            },
            required: ["message"],
        },
    },
    async execute(args, context) {
        return {
            id: "",
            name: "echo",
            success: true,
            output: `Echo: ${args.message}`,
            durationMs: 0,
        };
    },
};
// Mock 工具：总是失败
const failTool = {
    definition: {
        name: "fail",
        description: "总是失败的工具",
        parameters: { type: "object", properties: {} },
    },
    async execute(args, context) {
        throw new Error("故意失败");
    },
};
describe("ToolExecutor", () => {
    it("should register and execute tools", async () => {
        const executor = new ToolExecutor({
            tools: [echoTool],
            workspaceRoot: "/tmp/test",
        });
        const request = {
            id: "req-1",
            name: "echo",
            arguments: { message: "Hello" },
        };
        const result = await executor.execute(request, "conv-1");
        expect(result.success).toBe(true);
        expect(result.output).toBe("Echo: Hello");
        expect(result.id).toBe("req-1");
        expect(result.name).toBe("echo");
    });
    it("should return error for unknown tool", async () => {
        const executor = new ToolExecutor({
            tools: [echoTool],
            workspaceRoot: "/tmp/test",
        });
        const request = {
            id: "req-2",
            name: "unknown",
            arguments: {},
        };
        const result = await executor.execute(request, "conv-1");
        expect(result.success).toBe(false);
        expect(result.error).toContain("未知工具");
    });
    it("should catch and report tool execution errors", async () => {
        const executor = new ToolExecutor({
            tools: [failTool],
            workspaceRoot: "/tmp/test",
        });
        const request = {
            id: "req-3",
            name: "fail",
            arguments: {},
        };
        const result = await executor.execute(request, "conv-1");
        expect(result.success).toBe(false);
        expect(result.error).toBe("故意失败");
    });
    it("should return tool definitions for model", () => {
        const executor = new ToolExecutor({
            tools: [echoTool, failTool],
            workspaceRoot: "/tmp/test",
        });
        const definitions = executor.getDefinitions();
        expect(definitions).toHaveLength(2);
        expect(definitions[0].type).toBe("function");
        expect(definitions[0].function.name).toBe("echo");
    });
    it("should call audit logger", async () => {
        const auditLogs = [];
        const executor = new ToolExecutor({
            tools: [echoTool],
            workspaceRoot: "/tmp/test",
            auditLogger: (log) => auditLogs.push(log),
        });
        await executor.execute({ id: "req-4", name: "echo", arguments: { message: "test" } }, "conv-audit");
        expect(auditLogs).toHaveLength(1);
        expect(auditLogs[0].toolName).toBe("echo");
        expect(auditLogs[0].conversationId).toBe("conv-audit");
        expect(auditLogs[0].success).toBe(true);
    });
    it("should sanitize sensitive arguments in audit log", async () => {
        const auditLogs = [];
        const executor = new ToolExecutor({
            tools: [echoTool],
            workspaceRoot: "/tmp/test",
            auditLogger: (log) => auditLogs.push(log),
        });
        await executor.execute({ id: "req-5", name: "echo", arguments: { message: "hi", api_key: "secret123" } }, "conv-1");
        expect(auditLogs[0].arguments.api_key).toBe("[REDACTED]");
        expect(auditLogs[0].arguments.message).toBe("hi");
    });
    it("should execute multiple tools in parallel", async () => {
        const executor = new ToolExecutor({
            tools: [echoTool],
            workspaceRoot: "/tmp/test",
        });
        const requests = [
            { id: "req-a", name: "echo", arguments: { message: "A" } },
            { id: "req-b", name: "echo", arguments: { message: "B" } },
        ];
        const results = await executor.executeAll(requests, "conv-batch");
        expect(results).toHaveLength(2);
        expect(results[0].output).toBe("Echo: A");
        expect(results[1].output).toBe("Echo: B");
    });
});
describe("DEFAULT_POLICY", () => {
    it("should have sensible defaults", () => {
        expect(DEFAULT_POLICY.deniedPaths).toContain(".env");
        expect(DEFAULT_POLICY.deniedPaths).toContain(".git");
        expect(DEFAULT_POLICY.maxTimeoutMs).toBeGreaterThan(0);
        expect(DEFAULT_POLICY.maxResponseBytes).toBeGreaterThan(0);
    });
});
//# sourceMappingURL=executor.test.js.map