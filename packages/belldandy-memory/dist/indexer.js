import * as fs from "node:fs/promises";
import * as path from "node:path";
import * as crypto from "node:crypto";
import * as chokidar from "chokidar";
import { Chunker } from "./chunker.js";
export class MemoryIndexer {
    store;
    chunker;
    options;
    watcher = null;
    constructor(store, options = {}) {
        this.store = store;
        this.chunker = new Chunker(options.chunkOptions);
        this.options = {
            extensions: options.extensions ?? [".md", ".txt"],
            chunkOptions: options.chunkOptions ?? {},
            ignorePatterns: options.ignorePatterns ?? ["node_modules", ".git", "dist", "build", ".belldandy"],
            watch: options.watch ?? false,
            watchDebounceMs: options.watchDebounceMs ?? 1000,
        };
    }
    /** 索引指定目录（递归） */
    async indexDirectory(dirPath) {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dirPath, entry.name);
            if (this.options.ignorePatterns.some((pattern) => fullPath.includes(pattern))) {
                continue;
            }
            if (entry.isDirectory()) {
                await this.indexDirectory(fullPath);
            }
            else if (entry.isFile()) {
                const ext = path.extname(entry.name).toLowerCase();
                if (this.options.extensions.includes(ext)) {
                    await this.indexFile(fullPath);
                }
            }
        }
    }
    /** 索引单个文件 */
    async indexFile(filePath) {
        try {
            const stats = await fs.stat(filePath);
            const mtime = stats.mtime.toISOString();
            // 检查增量：对比存储中的最后更新时间与文件修改时间
            // 注意：这里我们简单地用 chunks 中最新的 updated_at（实际上是索引入库时间） vs 文件 mtime
            // 为了更严谨，我们应该在 metadata 里存原始文件的 mtime
            // 但这里我们先对比库里是否有记录。如果有，且记录的 file_mtime >= 当前文件 mtime，则跳过
            const fileMeta = this.store.getFileMetadata(filePath);
            if (fileMeta && fileMeta.metadata?.file_mtime) {
                if (new Date(fileMeta.metadata.file_mtime) >= stats.mtime) {
                    // 没变，跳过
                    return;
                }
            }
            // 读取并分块
            const content = await fs.readFile(filePath, "utf-8");
            const chunksStr = this.chunker.splitText(content);
            // 事务性更新：先删旧，再插新
            // 注意：SQLite DatabaseSync 暂时没有显式 transaction API (Node 22)，
            // 但我们可以顺序执行。如果中间失败，可能导致数据不一致。
            // 对于 MVP，我们可以接受。
            this.store.deleteBySource(filePath);
            const baseId = crypto.createHash("md5").update(filePath).digest("hex");
            // Determine memory type
            const fileName = path.basename(filePath);
            const parentDir = path.basename(path.dirname(filePath));
            let memoryType = "other";
            if (fileName === "MEMORY.md" || fileName === "memory.md") {
                memoryType = "core";
            }
            else if (parentDir === "memory" && /^\d{4}-\d{2}-\d{2}\.md$/.test(fileName)) {
                memoryType = "daily";
            }
            for (let i = 0; i < chunksStr.length; i++) {
                const chunkContent = chunksStr[i];
                const chunk = {
                    id: `${baseId}_${i}`,
                    sourcePath: filePath,
                    sourceType: "file",
                    memoryType: memoryType,
                    content: chunkContent,
                    metadata: {
                        file_mtime: mtime, // 存入文件的实际修改时间
                        chunk_index: i,
                        total_chunks: chunksStr.length
                    }
                };
                this.store.upsertChunk(chunk);
            }
            // 更新全局索引时间
            this.store.updateLastIndexedAt();
        }
        catch (err) {
            console.error(`Failed to index file: ${filePath}`, err);
        }
    }
    /** 停止监听 */
    async stopWatching() {
        if (this.watcher) {
            await this.watcher.close();
            this.watcher = null;
        }
    }
    /** 启动目录监听 */
    async startWatching(dirPath) {
        if (this.watcher)
            return;
        console.log(`[MemoryIndexer] Starting watch on: ${dirPath}`);
        this.watcher = chokidar.watch(dirPath, {
            ignored: (pathStr) => {
                // Ignore dotfiles (except .belldandy config maybe? no, usually ignore hidden)
                // Actually we explicitly ignore .git and node_modules in ignoredPatterns.
                // Chokidar ignored function: return true to ignore.
                return this.options.ignorePatterns.some(pattern => pathStr.includes(pattern));
            },
            persistent: true,
            ignoreInitial: true, // Don't re-index everything on start (we rely on indexDirectory for initial scan)
            awaitWriteFinish: {
                stabilityThreshold: this.options.watchDebounceMs,
                pollInterval: 100
            }
        });
        const handleFile = async (filePath) => {
            const ext = path.extname(filePath).toLowerCase();
            if (this.options.extensions.includes(ext)) {
                console.log(`[FileChanged] ${path.relative(dirPath, filePath)}`);
                await this.indexFile(filePath);
            }
        };
        const handleRemove = async (filePath) => {
            // If extension matches, delete from store
            const ext = path.extname(filePath).toLowerCase();
            if (this.options.extensions.includes(ext)) {
                console.log(`[FileRemoved] ${path.relative(dirPath, filePath)}`);
                this.store.deleteBySource(filePath);
            }
        };
        this.watcher
            .on("add", handleFile)
            .on("change", handleFile)
            .on("unlink", handleRemove)
            .on("error", error => console.error(`[WatcherError] ${error}`));
    }
}
//# sourceMappingURL=indexer.js.map