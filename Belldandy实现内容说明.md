# Belldandy 实现内容说明

本文档详细介绍了 Belldandy 项目已完成的功能模块及后续规划，旨在帮助开发者和使用者深入理解系统设计与能力。同时，为了方便对比与参考，附录部分详细列出了参考目标 **openclaw** 的完整能力清单。

## 1. 范围与约束

- **开发目录**：`e:\project\Belldandy`
- **参考目录（只读）**：`E:\project\belldandy\openclaw`（不修改、不编码）
- **参考目录（只读）**：`E:\project\belldandy\UI-TARS-desktop-main`（不修改、不编码）

## ✅ 已完成功能模块

### 1. 基础架构与 WebChat (Phase 1-2)

- **目标**：搭建最小可用、端到端的实时对话系统闭环。
- **实现内容**：
    - **Gateway**：基于 WebSocket 的消息总线，处理客户端连接、鉴权与消息路由。
    - **Agent Runtime**：支持流式输出（Streaming）的 Agent 运行环境，默认集成 MockAgent（本地测试）与 OpenAI 协议兼容 Provider。
    - **WebChat**：轻量级 Web 前端，支持自动重连、Markdown 渲染、实时消息流展示。
    - **协议**：定义了 `message.send`、`chat.delta`、`chat.final` 等标准事件格式。
- **价值**：作为系统的骨架，确保了“输入-处理-输出”核心链路的稳定与即时响应。

### 2. 安全准入与 Pairing 机制 (Phase 3 & 3.1)

- **目标**：遵循“默认安全”原则，保护 Agent 不被未授权的设备或用户访问。
- **实现内容**：
    - **强制配对**：所有未知来源的连接请求会被拒绝，并触发 Pairing 流程。
    - **Allowlist**：基于 ClientId 的白名单机制，只有授权设备才能与 Agent 对话。
    - **CLI 管理工具**：提供了全套命令行工具管理授权：
        - `pairing:list` / `pairing:pending`：查看授权状态与待处理请求。
        - `pairing:approve <CODE>`：批准配对请求。
        - `pairing:cleanup`：一键清理过期的请求。
        - `pairing:export` / `pairing:import`：配置数据的备份与恢复。
- **价值**：确保个人 AI 助手的私密性，防止被局域网内的其设备意外调用或恶意扫描。

### 3. Skills 工具系统 (Phase 4)

- **目标**：赋予 Agent 操作外部世界的能力，突破 LLM 的知识截止限制。
- **实现内容**：
    - **工具沙箱**：`@belldandy/skills` 包提供了安全的工具执行环境与审计日志功能。
    - **内置工具**：
        - `web_fetch`：受控的网页抓取工具（含域名白/黑名单、内网 IP 阻断、超时与大小限制）。
        - `file_read` / `file_write`：受控的文件读写工具（防目录遍历、敏感文件黑名单、显式写入许可）。
            - **写入模式**：`overwrite/append/replace/insert`，支持按行号或正则进行局部替换。
            - **项目感知**：默认自动创建父目录；支持跨工作区根目录（`BELLDANDY_EXTRA_WORKSPACE_ROOTS`）。
            - **格式策略**：允许扩展名白名单、点文件、base64（二进制）写入策略化控制。
            - **脚本权限**：非 Windows 下写入 `.sh` 自动 `chmod +x`。
    - **Function Calling**：实现了 `ToolEnabledAgent`，支持“思考-调用工具-获取结果-再思考”的 ReAct 循环。
- **价值**：让 Agent 可以联网搜索最新信息、阅读本地文档、甚至协助编写代码文件，极大地扩展了其实用性。

### 4. Memory 记忆系统 (Phase 4 & 4.5)

- **目标**：赋予 Agent 长期记忆，使其随着使用越来越了解用户，并能回忆起过去的对话与知识。
- **实现内容**：
    - **混合检索内核**：基于 SQLite 实现，结合了 **FTS5 关键词检索**（BM25）与 **`sqlite-vec` 向量语义检索**（Native C++ KNN）。
    - **智能索引**：
        - `Chunker`：基于 Token 估算的智能文本分块。
        - `MemoryIndexer`：增量式文件索引，自动扫描 `~/.belldandy/memory/` 目录。
    - **物理分层存储**：
        - **数据库层**：SQLite 中 `chunks` 表新增 `memory_type` 字段 (`core` | `daily` | `other`)，实现物理隔离与差异化检索。
        - **文件映射**：
            - `MEMORY.md` ➜ `core` (长期记忆/事实)
            - `memory/YYYY-MM-DD.md` ➜ `daily` (短期流水/日志)
    - **Embedding 集成**：支持对接 OpenAI 兼容的 Embedding API 生成向量。
    - **Memory Tools**：提供了 `memory_search` 工具，让 Agent 能自主发起检索。
- **价值**：解决了 LLM 上下文窗口限制问题，并实现了长期核心记忆与短期流水的结构化分离，为未来的差异化权重检索奠定基础。

### 5. 对话上下文与防注入 (Phase 2.2)

- **目标**：在保持对话连续性的同时，严格防御 Prompt Injection 攻击，确保 Agent 人格不被覆盖。
- **实现内容**：
    - **ConversationStore**：内存中的会话管理器，处理会话 TTL（自动过期）与最大历史长度限制。
    - **分层 Prompt 架构**：严格隔离数据层级：
        1. **System Layer**：系统指令与人格设定（最高优先级，用户不可见）。
        2. **History Layer**：过往对话历史。
        3. **User Layer**：当前用户输入（被视为普通内容而非指令）。
- **价值**：增强了系统的健壮性与安全性，避免用户通过恶意指令（如“忽略前面所有指令”）篡改 Agent 的核心行为准则。

### 6. SOUL 人格系统 (Phase 5)

- **目标**：赋予 Agent 独特、连续且可配置的个性，使其不仅仅是一个问答机器。
- **实现内容**：
    - **Workspace 引导体系**：系统启动时自动加载 `~/.belldandy/` 下的定义文件
    - **动态注入**：Gateway 在每一轮对话中都会将这些设定动态组合进 System Prompt
- **价值**：提供了高度的可玩性与定制化空间，用户可以像写小说一样塑造自己专属 AI 的性格。

#### Workspace 文件读取时机机制

| 文件 | 创建时机 | 读取时机 | 注入到 System Prompt | 说明 |
|------|---------|----------|---------------------|------|
| **AGENTS.md** | 启动时缺失则创建 | ✅ 每次会话 | ✅ 是（第一个） | 工作空间使用指南 |
| **SOUL.md** | 启动时缺失则创建 | ✅ 每次会话 | ✅ 是 | 核心人格定义 |
| **TOOLS.md** | 启动时缺失则创建 | ✅ 每次会话 | ✅ 是 | 本地工具/环境说明 |
| **IDENTITY.md** | 启动时缺失则创建 | ✅ 每次会话 | ✅ 是 | Agent 身份信息 |
| **USER.md** | 启动时缺失则创建 | ✅ 每次会话 | ✅ 是 | 用户档案 |
| **HEARTBEAT.md** | 启动时缺失则创建 | ✅ 定时读取 | ❌ 否 | 定时任务配置 |
| **BOOTSTRAP.md** | **仅全新工作区** | ⚠️ 仅存在时 | ✅ 是 | 首次引导仪式 |

#### 文件创建规则

- **全新工作区**（所有核心文件都不存在）：创建全部 7 个文件，包括 BOOTSTRAP.md
- **已有工作区**：只创建缺失的核心文件，**不**创建 BOOTSTRAP.md

#### BOOTSTRAP.md 生命周期

1. 全新工作区启动时自动创建
2. Agent 读取后开始"苏醒对话"
3. 引导完成后 Agent 更新 IDENTITY.md、USER.md
4. Agent 删除 BOOTSTRAP.md，结束引导阶段

---


### 7. 插件系统 (Plugin System) Phase 8

- **目标**：建立标准化的扩展机制，允许通过外部 JS/MJS 文件动态扩展 Agent 能力。
- **实现内容**：
    - **PluginRegistry**：插件加载的核心注册表，支持运行时动态加载。
    - **AgentHooks**：实现了生命周期钩子（`beforeRun`, `beforeToolCall`, `afterToolCall`, `afterRun`），允许插件干预 Agent 决策流程。
    - **Tool Extension**：插件可以注册新的 Tool 到 Agent 的工具箱中。
- **价值**：为未来的生态扩展打下基础（如接入 1Password, Linear 等第三方服务）。

### 7.1 钩子系统扩展 (Hook System Extension) Phase 8.3

- **目标**：对标 moltbot 实现完整的 13 种生命周期钩子，支持优先级、双执行模式、错误处理。
- **实现内容**：
    - **HookRegistry**：钩子注册表，支持按来源注册/注销、优先级排序（priority 越高越先执行）。
    - **HookRunner**：钩子执行器，支持三种执行模式：
        - **并行执行 (runVoidHook)**：适用于日志、审计等无返回值场景
        - **顺序执行 (runModifyingHook)**：适用于需要修改参数或取消操作的场景
        - **同步执行 (runToolResultPersist)**：用于热路径中的工具结果持久化
    - **13 种钩子**：
        | 类别 | 钩子名称 | 执行模式 | 用途 |
        |------|---------|---------|------|
        | Agent | `before_agent_start` | 顺序 | 注入系统提示词/上下文 |
        | Agent | `agent_end` | 并行 | 分析完成的对话 |
        | Agent | `before_compaction` | 并行 | 上下文压缩前处理 |
        | Agent | `after_compaction` | 并行 | 上下文压缩后处理 |
        | 消息 | `message_received` | 并行 | 消息接收日志 |
        | 消息 | `message_sending` | 顺序 | 修改或取消即将发送的消息 |
        | 消息 | `message_sent` | 并行 | 消息发送日志 |
        | 工具 | `before_tool_call` | 顺序 | 修改参数或阻止调用 |
        | 工具 | `after_tool_call` | 并行 | 结果审计 |
        | 工具 | `tool_result_persist` | 同步 | 修改持久化的工具结果 |
        | 会话 | `session_start` | 并行 | 初始化会话级资源 |
        | 会话 | `session_end` | 并行 | 清理会话级资源 |
        | 网关 | `gateway_start` | 并行 | 服务初始化 |
        | 网关 | `gateway_stop` | 并行 | 服务清理 |
    - **向后兼容**：保留原有的 `AgentHooks` 简化接口，内部转换为新的注册机制。
- **关键文件**：
    ```
    packages/belldandy-agent/src/
    ├── hooks.ts          # 完整类型定义 + HookRegistry
    ├── hook-runner.ts    # 钩子执行器（新增）
    ├── tool-agent.ts     # 集成新版 hookRunner
    └── index.ts          # 导出新增类型
    ```
- **价值**：与 moltbot 完全对标，为插件系统提供完整的生命周期干预能力。

### 8. 浏览器扩展 (Phase 9)

- **目标**：突破传统 API 的限制，让 Agent 直接接管用户的浏览器，复用登录态与浏览历史。
- **实现内容**：
    - **Relay Server**：一个 WebSocket 中继服务，模拟 CDP (Chrome DevTools Protocol)，让 Puppeteer 可以连接到真实的浏览器扩展。
    - **Chrome Extension**：基于 Manifest V3 (MV3) 开发，利用 `chrome.debugger` API 接管 Tab。
    - **Agent Integration**：封装了标准的 Browser Tools (`browser_open`, `browser_screenshot`, `browser_get_content`, `browser_snapshot`)。
- **Phase 9.5 能力增强**：
    - **增强阅读 (Enhanced Reading)**：
        - `browser_get_content` 集成了 **Readability** 算法与 Markdown 转换，能够提取网页正文去除噪声，大幅提升阅读体验并降低 Token 消耗。
    - **视觉反馈 (Visual Feedback)**：
        - `browser_screenshot` 实现了完整的截图与自动归档流程（保存至 `screenshots/`），赋予 Agent "看见" 网页实际渲染效果的能力。
- **技术突破**：
    - 解决了 Puppeteer 与 Extension 之间的 Target ID 映射差异。
    - 实现了自动化中继启动（随 Gateway 拉起）。
    - 攻克了 Extension 环境下的目标发现竞态条件（Race Condition）。
    - **交互式 DOM 快照 (Interactive DOM Snapshot)**：
        - 智能过滤无关噪音（script/style/div），只保留内容与交互元素。
        - 自动分配数字 ID (`[42]`)，Agent 可直接通过 ID 点击元素，无需生成复杂 CSS Selector。
        - Token 消耗降低 50%-80%。
- **价值**：赋予 Agent "看"网页（截图/快照）和"动"网页（点击/输入）的能力，是实现复杂 Web 任务自动化的基石。

### 8. 系统级操作 (System Execution) Phase 10
- **目标**：赋予 Agent 在宿主机执行 Shell 命令的能力，但必须保证宿主机安全。
- **策略**：**Consumer Safe Mode (消费者安全模式)**
    - **严格白名单**：覆盖主流开发工具（Node/Python/编译链/Java/.NET/媒体/文档转换），并区分 Windows/Unix 命令差异。
    - **非交互保护**：对常见命令自动追加 `-y/--yes` 等参数，避免卡在交互输入。
    - **超时与强杀**：快速命令默认 5s、构建命令 300s，超时后强制 kill 进程。
    - **风险阻断**：
        - 🚫 **Blocklist**：`sudo`, `su`, `mkfs`, `dd` 等特权/破坏指令直接拦截。
        - ⚠️ **Arg Check**：允许 `rm` / `del` 但 **严禁** `rm -r/-rf` 与 `del /s /q`。
        - 🔒 **敏感保护**：`SOUL.md` 访问优先拦截；禁止通过 `exec` 读取 `.env`。
- **价值**：填补了 Agent 无法执行 `npm install` 或 `git commit` 的能力空白，使其成为真正的"全栈工程师"。

### 9. 实时文件感知 (Real-time File Perception) Phase 11

- **目标**：让 Agent 能够即时感知用户对文件的修改，无需重启或手动刷新。
- **实现内容**：
    - **Watcher**：集成 `chokidar` 监听工作空间文件变化（add/change/unlink）。
    - **Incremental Indexing**：文件修改后 1秒内自动触发增量索引，更新 Memory 数据库。
    - **Auto Cleanup**：文件删除时自动清理对应的 chunks 和 vectors。
- **价值**：消除了 AI 记忆滞后的问题，特别是对于 Coding 场景，Agent 永远知道最新的代码状态。

### 10. Model Failover & High Availability (Phase 8) [已完成]

- **目标**：实现类似 OpenClaw 的模型调用容灾机制，确保高可用性。
- **状态**：✅ 已完成 (2026-02-10)
- **实现内容**：
    - **FailoverClient**（`failover-client.ts`）：封装底层 HTTP 请求，内置错误分类 + Cooldown（熔断冷却）+ 多 Profile 自动轮询。
    - **错误分类**：429/5xx/408/超时 → 触发 failover；400 → 不可重试直接返回。
    - **Cooldown 策略**：rate_limit 冷却 2 分钟，billing (402) 冷却 10 分钟，其他 1 分钟。
    - **Agent 集成**：`OpenAIChatAgent` 和 `ToolEnabledAgent` 均已接入 `FailoverClient.fetchWithFailover`。
    - **配置加载**：Gateway 启动时自动从 `~/.belldandy/models.json`（或 `BELLDANDY_MODEL_CONFIG_FILE`）加载备用 Profile。
    - **向后兼容**：未配置 `models.json` 时行为与之前完全一致。
- **价值**：提升系统的鲁棒性，确保关键时刻 AI 不"掉链子"。多 Key 负载均衡 + 跨 Provider 降级双重保障。

### 10. 性能与向量加速 (Vector Optimization) Phase 12

- **目标**：引入 `sqlite-vec` 替换纯 JS 的向量计算，实现生产级性能。
- **实现内容**：
    - **核心引擎**：引入 `sqlite-vec` (C++ Extension) 提供底层的 SIMD 加速支持。
    - **存储升级**：使用 `vec0` 虚拟表存储高维向量（替代 BLOB），支持高效的 L2/Cosine 距离计算。
    - **架构优化**：
        - 移除应用层所有计算开销，直接下沉到 SQLite SQL 查询（`WHERE embedding MATCH ?`）。
        - 实现了 `rowid` 映射机制，确保 Metadata 表与 Vector 表的强一致性。
- **性能飞跃**：
    - 检索延迟：**~12ms** (10k 向量)，相比 JS 实现提升显著。
    - 内存占用：大幅降低，不再需要将所有向量加载到 Node.js 堆内存中。
- **价值**：支撑海量记忆（百万级 Chunk）的基础设施升级，让 Belldandy 有能力管理整个代码库的知识。

### 11. 多媒体与语音 (Multimedia & TTS) Phase 13

- **目标**：实现高质量、低成本的语音交互能力。
- **技术方案**：
    - **Multi-Provider 架构**：重构 `text_to_speech` 工具，抽象出 Provider 接口，同时支持 `openai` (REST API) 和 `edge` (WebSocket 逆向)。
    - **Node-Edge-TTS**：选用 `node-edge-tts` 库，无需安装浏览器即可通过 WebSocket 协议调用 Azure 顶级神经元语音（晓晓/云希）。
    - **静态资源服务**：Gateway 新增 `/generated` 静态路由，将本地生成的 MP3 文件暴露为 HTTP 链接，供前端 `<audio>` 标签播放。
    - **动态 System Prompt**：实现文件信号机制 (`TTS_ENABLED`)。Gateway 每次请求前检查该文件，若存在则动态注入 "MUST use text_to_speech tool" 的 System Prompt 指令，实现无需重启的热开关。
- **价值**：极大提升了交互的拟人感，且利用 Edge TTS 实现了零成本的高质量语音体验。

### 12. 视觉感知 (Vision) Phase 13.5

- **目标**：赋予 Agent 视觉能力，使其能够"看到"物理世界。
- **实现内容**：
    - **回环视觉 (Loopback Vision)**：利用现有的 Browser Extension + WebDriver 协议。
    - **Mirror Page**：Gateway 托管 `/mirror.html`，调用 `navigator.mediaDevices.getUserMedia` 显示摄像头画面。
    - **Agent Action**：Agent 使用 `browser_navigate` 打开页面，然后使用 `browser_screenshot` 获取视觉帧。
- **价值**：无需引入复杂的 WebRTC 或流媒体协议，复用现有浏览器能力实现"看世界"。

### 12.5 Kimi 原生视觉 (Native Multimodal Vision) Phase 13.6

- **目标**：支持用户直接发送图片给 Agent，利用 Kimi K2.5 的多模态能力进行理解。
- **状态**：✅ 已完成 (2026-02-10)
- **实现内容**：
    - **协议升级**：重构 `AgentRunInput` 接口，支持混合多模态内容（`Array<Text | ImageURL>`）。
    - **透明传输**：Gateway (`server.ts`) 自动检测 MIME 类型，将图片附件转换为 Base64 `image_url` 对象。
    - **混合兼容**：
        - **图片**：作为视觉输入直接传给模型。
        - **文本/代码**：作为文本附件追加到 Prompt。
        - **其他文件**：保持路径引用。
- **价值**：
    - **原生理解**：无需 OCR 中转，模型能直接理解梗图、UI 截图、图表细节。
    - **交互升级**：用户可以“发图提问”，交互体验大幅提升。

### 13. 方法论系统 (Methodology) Phase 14

- **目标**：让 Agent 具备"自我进化"与"经验沉淀"能力。
- **实现内容**：
    - **Methodology Skills**：
        - `method_list` / `method_search`：查找现有 SOP。
        - `method_read`：读取 SOP 步骤。
        - `method_create`：沉淀新的经验方法。
    - **Prompt Injection**：System Prompt 中注入 "Methodology Protocol"，强制 Agent 在复杂任务前查阅、任务后反思。
    - **Runtime Support**：自动管理 `~/.belldandy/methods` 目录。
- **价值**：解决 Agent "用完即忘"的问题，将隐性知识显性化为可复用的 Markdown 文档。

### 14. 会话持久化与向量记忆 (Persistence & Vector Memory) Phase 4.6

- **目标**：实现会话数据的持久化存储，并利用向量索引实现“无限”的记忆 recall。
- **状态**：✅ 已完成 (2026-02-08)
- **实现内容**：
    - **Session Persistence**：
        - `ConversationStore` 升级为文件支持。
        - 实时将会话写入 `.belldandy/sessions/<conversationId>.jsonl`。
        - 重启后自动加载最近会话，上下文不丢失。
    - **Session Indexing**：
        - `MemoryIndexer` 支持 `.jsonl` 格式解析。
        - 自动监听 `sessions` 目录，增量生成向量索引。
        - 实现了 `session` 类型的记忆块 (`memory_type='session'`)。
        - 解决了首次启动时向量表未初始化的 Bootstrap 问题。
        - `MemoryManager` 启动时自动检测并补全缺失的 Embedding。
    - **Configuration**:
        - 支持自定义 Embedding 模型配置（如适配 `text-embedding-v1`）。
        - 实现了环境变量优先级逻辑 (`BELLDANDY_` > `OPENAI_`)。
- **价值**：
    - **数据安全**：意外崩溃或重启不再丢失当前对话。
    - **全渠道记忆**：无论是网页还是飞书，对话记录都统一归档并在未来可检索。
    - **长程记忆**：Agent 可以通过 `memory_search` 回忆起几天甚至几个月前的对话细节。

### 15. 记忆检索增强 (Memory Retrieval Enhancement) Phase 4.7

- **目标**：让 Agent 更主动、更智能地使用长期记忆，从"被动回忆"升级为"主动关联"。
- **状态**：部分完成 (2026-02-08)
- **已完成**：
    - **Global MemoryManager**：统一 Gateway 与 Skills 的 MemoryManager 实例，让 `memory_search` 工具能访问会话向量索引。
    - **Prompt 引导**：在 `AGENTS.md` 中添加记忆检索策略规则，引导 Agent 在遇到回忆类问题时主动使用 `memory_search`。
- **规划中**：
    - **Context Injection**：每次对话开始时，自动从 sessions 中提取最近对话摘要，注入 System Prompt。
    - **Auto-Recall**：使用 NLP 检测用户输入中的"回忆类"关键词，自动触发 `memory_search` 并将结果注入上下文。
- **价值**：让 Agent 像人类一样自然地回忆，而非机械地等待用户显式请求。

---

## 16. 记忆系统未来优化规划 (Planned)

虽然当前系统已具备基础的向量检索能力，但为了进一步提升记忆的“智能感”，我们规划了以下三个优化方向（待适时落地）：

1.  **自动摘要 (Auto-Summarization)**
    - **痛点**：长期对话会导致记忆碎片化，缺乏宏观结论。
    - **方案**：每日或定期触发 LLM 对近期对话生成 **High-Level Summary**，并作为独立记忆块存入，便于检索“结论”而非“过程”。

2.  **元数据过滤 (Metadata Filtering)**
    - **痛点**：全量检索可能混杂不同渠道、不同话题的无关信息。
    - **方案**：在记忆块中注入 `channel`、`topic`、`timestamp` 等结构化标签，检索时支持 SQL 级预过滤（Pre-filtering），如“只查飞书上的技术讨论”。

3.  **查询重写与重排序 (Rewrite & Rerank)**
    - **痛点**：用户指代不清（“它怎么样？”）导致检索失败；向量相似度不等于逻辑相关度。
    - **方案**：
        - **Rewrite**：先用 LLM 将用户查询改写为完整句子（消歧），再检索。
        - **Rerank**：引入精细的 Rerank 模型对初步检索的 Top-50 结果进行二次打分，筛选出真正相关的 Top-5。

---

## 16. OS 计算机操作能力规划 (Computer Use Strategy) [Planned]

基于 `UI-TARS` 的最佳实践（“看得准”与“点得准”），我们计划赋予 Belldandy 操作系统级别的 GUI 控制能力，使其不局限于浏览器和终端。

1.  **视觉层：精准屏幕感知 (High-Fidelity Vision)**
    - **DPI 适配**: 引入 `nut-js` + `Jimp` 方案，正确处理 Retina/高分屏缩放 (Scale Factor)，保证模型看到的与真实物理像素一致。
    - **Visual Feedback**: 实现 `ScreenMarker` (透明置顶窗口)，在执行点击前通过高亮框/光标实时展示模型意图，让用户“看得见”Agent 想点哪。

2.  **控制层：拟人化键鼠操作 (Human-like Input)**
    - **坐标映射**: 实现统一的 `Box-to-Pixel` 转换器，将 VLM 返回的归一化坐标精准映射到物理屏幕。
    - **输入优化**:
        - **Keyboard**: Windows 下优先使用 **剪贴板粘贴 (Ctrl+V)** 替代逐字输入，彻底解决 IME 输入法干扰和字符丢失问题。
        - **Mouse**: 使用线性插值 (`straightTo`) 移动路径，避免瞬移被反外挂检测，同时增加操作的自然感。

### 6. Phase 2.5: 可视化配置 & System Doctor (用户体验升级)

**状态**：✅ 已完成

为了解决“手动改配置文件太极客”的痛点，我们在 WebChat 中集成了**可视化配置面板**。

#### ✨ 功能亮点
1.  **Lenient Mode (宽容模式)**：
    *   Gateway 启动时不再强校验 API Key。
    *   即使用户什么都没配，也能打开界面（不会白屏/Crash）。
    *   只有在真正发消息时，才会提示“配置缺失”并弹出设置窗。
2.  **Settings UI (配置面板)**：
    *   点击右上角“⚙️”图标即可打开。
    *   支持修改 **OpenAI Key**, **Base URL**, **Model**, **Heartbeat Interval**。
    *   **Auto-Save & Restart**: 点击 Save 后，自动更新 `.env.local` 并重启后端进程（配合 `start.sh/bat` 守护进程实现）。
3.  **System Doctor (系统体检)**：
    *   面板顶部实时显示 Health Badge。
    *   检查项：Node.js 版本、Vector DB 状态、Agent Config 有效性。

#### 🛠️ 技术实现
*   **Backend**: 
    *   新增 `config.read` / `config.update` 协议（读写 `.env.local`）。
    *   新增 `system.doctor` 协议（自检）。
    *   新增 `system.restart` 协议（`process.exit(100)` 触发守护进程重启）。
*   **Frontend**: 
    *   原生 JS/CSS 实现 Modal 组件，无缝集成到现有 MVP。

### 7. Phase 3: 极致美学重构 (Ethereal Digital UI)

**状态**：✅ 已完成

**目标**：将功能性的 MVP 界面升级为具有高级感、沉浸感的用户体验。

**实现内容**：
- **Ethereal Design System**:
    - **视觉**: 采用 "Deep Void" 深空黑背景配合 "Divine Cyan" 青色霓虹点缀，营造赛博神性氛围。
    - **质感**: 广泛使用 CSS `backdrop-filter: blur` 实现高级磨砂玻璃效果 (Glassmorphism)。
    - **排版**: 引入 `Outfit` (Headings) 和 `Inter` (Body) 谷歌字体。
- **Awakening Ritual (唤醒仪式)**:
    - 实现了首次连接时的 **Boot Sequence** 动画。
    - 模拟终端自检日志滚动 (`Initializing Neural Interface...`)，赋予 AI "生命感"。
- **交互微调**:
    - **Smart Input**: 实现了 `textarea` 的高度自适应与 Shift+Enter 换行逻辑。
    - **Motion**: 添加了消息气泡的淡入上浮动画 (`fade-up`)。

---

## 🚧 待实现功能规划 (后续)

### 8. Phase 3.1: Pairing 管理完善 (Security)

- **目标**：将 Belldandy 接入飞书自建应用，利用其 WebSocket 模式实现无需内网穿透的实时对话。
- **状态**：**已完成**（2026-02-01）
- **实现内容**：`@belldandy/channels` 包 + FeishuChannel（WebSocket 长连接），消息去重，Kimi K2.5 工具调用兼容。

### 14. 渠道架构升级 (Channel Architecture) Phase 15

- **目标**：建立标准化的渠道接口，方便后续快速接入 Telegram、Discord、Slack 等社交平台。
- **状态**：**已完成**（2026-02-05）
- **实现内容**：
    - **Channel 通用接口**：定义了所有渠道必须实现的标准方法（`start`、`stop`、`sendProactiveMessage`）。
    - **ChannelManager**：渠道管理器，支持统一注册、启停、广播消息。
    - **FeishuChannel 适配**：飞书渠道已实现新接口，完全向后兼容。
- **接口设计**：
    ```typescript
    interface Channel {
        readonly name: string;           // 渠道名称: "feishu", "telegram"
        readonly isRunning: boolean;     // 运行状态
        start(): Promise<void>;          // 启动渠道
        stop(): Promise<void>;           // 停止渠道
        sendProactiveMessage(content: string, chatId?: string): Promise<boolean>;
    }
    ```
- **文件结构**：
    ```
    packages/belldandy-channels/src/
    ├── types.ts      # Channel 通用接口定义
    ├── manager.ts    # ChannelManager 管理器
    ├── feishu.ts     # 飞书渠道实现 (implements Channel)
    └── index.ts      # 统一导出
    ```
- **价值**：降低新渠道接入成本，只需实现 `Channel` 接口即可接入系统，预计每个新渠道开发周期可缩短至 1-2 天。

### 2. Phase 7: Heartbeat 定时任务 ✅ 已完成

- **目标**：让 Agent 能够定期"醒来"检查 HEARTBEAT.md 并主动联系用户。
- **状态**：**已完成**（2026-02-01）
- **实现内容**：
    - 心跳 Runner（`packages/belldandy-core/src/heartbeat/`）
    - 定时触发 + 活跃时段支持（深夜不打扰）
    - HEARTBEAT.md 内容解析（空文件跳过）
    - HEARTBEAT_OK 响应检测（无事静默，有事推送）
- **价值**：Agent 可以主动提醒用户，如每日日程检查、待办事项提醒等。

#### 💡 Moltbot 对标分析：Heartbeat 模块

| 功能特性 | Moltbot 实现 | Belldandy 实现 | 差异/优化点 |
|---------|-------------|----------------|------------|
| **基础触发** | 定时器 + Command Queue 检查 | 简单定时器 (setInterval) | Belldandy 尚未实现队列忙碌检测，可能在 Agent 繁忙时插队 |
| **活跃时段** | 支持 User/Local 时区，精确分钟控制 | 支持时区与 HH:MM 范围 | 基本一致，Moltbot 的时区处理更健壮 |
| **消息去重** | ✅ **支持** (24内重复内容静默) | ❌ **未实现** | **差异点**：Moltbot 防止了一件事重复唠叨，Belldandy 可能会重复提醒 |
| **空值优化** | ✅ 检查文件内容是否为空 (skip empty) | ✅ 检查文件内容是否为空 | 一致，节省 Token |
| **静默响应** | `HEARTBEAT_OK` token 检测 | `HEARTBEAT_OK` token 检测 | 一致 |
| **多 Agent** | 支持每个 Agent 独立频率与配置 | 全局单一配置 | 架构差异，当前够用 |

> **改进建议**：未来应引入消息去重机制（Deduplication），防止 Agent 在无法执行操作时反复发送同一条提醒。

### 2.5 Phase 7.5: Cron 定时任务系统 ✅ 方案 A 已完成

- **目标**：在 Heartbeat 之上，抽象通用定时任务调度，让 Agent 能按计划触发非心跳类任务。
- **状态**：**方案 A (轻量 MVP) 已完成**（2026-02-10）
- **定位**：Heartbeat = 周期性"意识"检查（批量、共享上下文），Cron = 精确调度独立任务（一次性提醒、周期报告等）。
- **实现内容**：
    - **核心模块** (`packages/belldandy-core/src/cron/`)：
        - `types.ts`：调度类型（`at` 一次性 / `every` 周期重复）、`systemEvent` Payload、Job 状态
        - `store.ts`：JSON 文件持久化（`~/.belldandy/cron-jobs.json`），原子写入，CRUD
        - `scheduler.ts`：30s 轮询引擎，活跃时段过滤，忙碌检测，`at` 执行后自动禁用/删除
        - `index.ts`：统一导出
    - **Agent 工具** (`packages/belldandy-skills/src/builtin/cron-tool.ts`)：
        - `list`：列出所有定时任务
        - `add`：创建任务（支持 `at` 和 `every` 两种调度）
        - `remove`：删除任务
        - `status`：查看调度器状态
    - **Gateway 集成**：
        - `BELLDANDY_CRON_ENABLED=true` 启用调度引擎
        - 复用 Heartbeat 的 `sendMessage`/`deliverToUser` 模式
        - 工具始终注册（即使调度器未启用也可管理任务列表）
- **使用示例**：
    - "每 4 小时提醒我站起来活动" → `cron add --every 14400000 --text "..."`
    - "下午 3 点提醒我开会" → `cron add --at "2026-02-10T15:00:00+08:00" --text "..."`

#### 🚀 方案 B 升级路径（未来按需）

| 升级项 | 内容 | 好处 |
|--------|------|------|
| **Cron 表达式** | 引入 `croner` 库，支持 5 字段表达式（如 `0 9 * * 1`） | 精确到分钟的复杂调度（"每周一 9 点"） |
| **Session 隔离** | `main` / `isolated` 会话目标 | 避免定时任务历史污染主会话上下文 |
| **agentTurn Payload** | 在隔离会话中启动独立 Agent 对话，支持模型/thinking 覆盖 | 重任务用 Opus，轻任务用便宜模型 |
| **Delivery 路由** | `announce` / `none` + 渠道定向推送 | 定时任务结果推送到指定飞书群/Telegram |
| **Gateway 协议** | `cron.*` 系列 RPC 方法 | 前端 WebChat 可直接管理定时任务 |
| **执行历史** | `run` / `runs` action | 手动触发 + 调试审计 |

### 3. MCP (Model Context Protocol) 支持 (Phase 17) ✅ 已完成

- **目标**：实现 MCP 协议支持，让 Belldandy 能够连接外部 MCP 服务器，获取第三方工具和数据源。
- **背景**：MCP 是 Anthropic 提出的标准化协议，moltbot 通过 ACP 实现了类似功能。
- **状态**：**已完成**（2026-02-05）
- **实现内容**：
    - **新建 `@belldandy/mcp` 包**：完整的 MCP 客户端实现
    - **类型定义 (types.ts)**：配置类型、运行时状态、事件类型等
    - **配置加载 (config.ts)**：使用 Zod 验证 `~/.belldandy/mcp.json` 配置
    - **MCP 客户端 (client.ts)**：支持 stdio/SSE 两种传输方式
    - **工具桥接 (tool-bridge.ts)**：MCP 工具 → Belldandy Skills 转换
    - **管理器 (manager.ts)**：多服务器连接管理、工具发现、事件处理
    - **Gateway 集成**：启动时自动初始化 MCP 并注册工具
- **配置示例** (`~/.belldandy/mcp.json`)：
    ```json
    {
      "version": "1.0.0",
      "servers": [
        {
          "id": "filesystem",
          "name": "文件系统",
          "transport": {
            "type": "stdio",
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path"]
          },
          "autoConnect": true,
          "enabled": true
        }
      ],
      "settings": {
        "defaultTimeout": 30000,
        "toolPrefix": true
      }
    }
    ```
- **新增环境变量**：
    | 变量 | 说明 |
    |------|------|
    | `BELLDANDY_MCP_ENABLED` | 启用 MCP 支持（默认 false） |
- **价值**：**开放生态**。用户可以接入任何 MCP 兼容的服务（1Password、GitHub、Notion、Slack 等），无需修改 Belldandy 代码即可扩展能力。

### 4. 日志系统 (Logging System) Phase 18 [核心已完成]

- **目标**：实现完整的文件日志系统，支持 Agent 回溯分析任务执行过程、错误排查和性能分析。
- **状态**：✅ 已完成
- **核心价值**：
    - **可观测性**：系统运行状态完全可追溯
    - **自我进化**：Agent 能基于历史日志学习和改进，与方法论系统协同
    - **运维友好**：自动轮转和清理，无需人工干预
- **实现内容**：
    - **Logger 核心**：统一的日志接口，支持 debug/info/warn/error 四个级别
    - **双输出**：同时输出到控制台（彩色）和文件（持久化）
    - **文件轮转**：
        - 按日期分文件：`logs/2026-02-05.log`
        - 按大小轮转：单文件超过 10MB 自动创建 `.1.log`、`.2.log`
    - **自动清理**：启动时清理超过保留天数（默认 7 天）的日志
    - **Agent 工具**：`log_read`、`log_search` 让 Agent 能读取日志进行自我分析
- **日志格式**：
    ```
    [2026-02-05T14:32:15.123+08:00] [INFO] [gateway] Server started on port 28889
    [2026-02-05T14:32:15.456+08:00] [DEBUG] [agent] Tool call: file_read {path: "..."}
    [2026-02-05T14:32:15.789+08:00] [WARN] [memory] Slow query detected: 1523ms
    [2026-02-05T14:32:16.012+08:00] [ERROR] [tools] web_fetch failed: ECONNREFUSED
    ```
- **日志目录**：
    ```
    ~/.belldandy/
    ├── logs/                       # 日志目录
    │   ├── 2026-02-05.log          # 当天日志
    │   ├── 2026-02-05.1.log        # 当天轮转文件
    │   ├── 2026-02-04.log          # 昨天日志
    │   └── ...
    ```
- **环境变量**：
    | 变量 | 说明 | 默认值 |
    |------|------|--------|
    | `BELLDANDY_LOG_LEVEL` | 最低日志级别 | `debug` |
    | `BELLDANDY_LOG_DIR` | 日志目录 | `~/.belldandy/logs` |
    | `BELLDANDY_LOG_MAX_SIZE` | 单文件最大大小 | `10MB` |
    | `BELLDANDY_LOG_RETENTION_DAYS` | 日志保留天数 | `7` |
- **与方法论系统的协同**：
    1. Agent 执行任务时，详细日志记录每一步操作与耗时
    2. 任务失败时，Agent 可通过 `log_search` 定位错误
    3. Agent 分析日志后，可调用 `method_create` 沉淀经验
    4. 下次遇到类似任务，Agent 先查阅方法论，避免重复踩坑
- **已完成扩展**：
    - MCP 全模块接入 logger（manager/client/config/tool-bridge）
    - tool-agent 钩子失败日志接入 logger
    - ToolExecutor auditLogger 接入，工具调用耗时写入日志
    - camera_snap 使用 context.logger

### 5. Local Embedding (优先级：低)

- **目标**：摆脱对 OpenAI Embedding API 的依赖，实现完全本地化的记忆检索。
- **实现内容**：
    - 引入 `node-llama-cpp` 或 `transformers.js` 等本地推理库。
    - 支持加载本地 Embedding 模型（如 `all-MiniLM-L6-v2` 或 `bge-m3`）。
    - 实现一个新的 `EmbeddingProvider` 接口实现类。
- **价值**： **隐私与成本**。不需要把记忆片段发给 OpenAI 计算向量，完全离线可用，且无 API 费用。但会增加内存占用和安装包体积。
- **工作量**：**中等**。主要挑战在于 Native 依赖的安装和模型文件的管理。

### 4. SOUL_EVIL 彩蛋 (优先级：低)

- **目标**：增加趣味性和“灵魂”感。
- **实现内容**：
    - 在特定触发条件下（如特定日期、特定指令、或随机概率），加载 `SOUL_EVIL.md` 替代默认的 `SOUL.md`。
    - Agent 的性格、语气会发生反转（模仿 moltbot 的彩蛋设计）。
- **价值**：**娱乐性**。让 AI 显得不那么死板。
- **工作量**：**低**。主要是逻辑判断和 System Prompt 的动态切换。

### 5. Memory Flush 机制 (优先级：低)

- **目标**：性能优化。
- **实现内容**：
    - 在记忆写入及索引过程中引入 Buffer 缓冲。
    - 在系统空闲或关闭前统一将内存中的变更写入磁盘（Compaction）。
- **价值**：**性能与硬盘寿命**。防止高频对话时频繁对 SQLite 进行微小写入。在目前单人使用且数据量不大的情况下，收益不明显。
- **工作量**：**低**。

---

## 🔐 安全与网络加固路线图 ✅ 已完成 (2026-02-08)

> 基于安全评估结果完成的加固工作，已在 Phase 19 落地实现。

### 1. P0：配对绕过风险 ✅

- **修复内容**：
  - 将 `workspace.read/list` 纳入 `secureMethods`（server.ts L245）
  - 敏感文件黑名单：`allowlist.json/pairing.json/mcp.json/feishu-state.json`（server.ts L507-512）

### 2. P1：CSWSH 防护 + 安全启动 ✅

- **修复内容**：
  - Origin Header 白名单校验，使用 `verifyClient` 回调（server.ts L84-112）
  - 新增 `BELLDANDY_ALLOWED_ORIGINS` 环境变量
  - `HOST=0.0.0.0` + `AUTH_MODE=none` 组合时强制退出（gateway.ts L281-286）

### 3. P1：配置泄露防护 ✅

- **修复内容**：
  - `config.read` 对敏感字段（`*KEY*/*SECRET*/*TOKEN*/*PASSWORD*`）返回 `[REDACTED]`（server.ts L346-356）
  - `config.update` 白名单限制，仅允许修改安全配置项（server.ts L363-376）

### 4. P2：危险工具 Opt-in ✅

- **修复内容**：
  - 新增 `BELLDANDY_DANGEROUS_TOOLS_ENABLED` 环境变量，默认 `false`（gateway.ts L318-319）
  - `run_command` 仅在显式启用时注册（gateway.ts L330-331）
  - 启用时输出警告日志（gateway.ts L378-381）

### 5. P2：SSRF 防护增强 ✅

- **修复内容**：
  - 新增 `dns.lookup` 解析后二次校验，防止 DNS Rebinding（fetch.ts L99-109）
  - 新增 `isPrivateIP` 函数校验解析后的 IP（fetch.ts L215-231）

### 6. P3：浏览器域名控制 ⏳ 待验证

- **已准备**：`BELLDANDY_BROWSER_ALLOWED_DOMAINS` 环境变量已添加到 `.env.example`
- **待实现**：实际域名校验逻辑（低优先级）

---

## 📚 附录：Moltbot 能力清单 (参考基准)

以下是参考项目 **moltbot** 目前已实现的完整能力清单，Belldandy 的开发正是为了逐步对齐这些能力。

### 1. 核心文件操作 (Core Coding)
Agent 可以像工程师一样直接操作项目代码。
- **`read_file_content`** / **`readTool`**：读取文件内容。
- **`list_files`**：列出目录结构。
- **`write_file`**：写入新文件或覆盖文件。
- **`edit_file`**：编辑现有文件（支持多处查找替换）。
- **`apply_patch`**：应用 Unified Diff 补丁。

### 2. 浏览器自动化 (Browser Control)
Agent 拥有一个极其强大的 **`browser`** 工具，可以控制无头浏览器与网页交互。
- **`status`**：检查浏览器状态。
- **`start`** / **`stop`**：启动/关闭浏览器实例。
- **`profiles`**：切换环境（`chrome`=接管用户浏览器扩展, `clawd`=隔离沙箱环境）。
- **`tabs`** / **`open`** / **`focus`** / **`close`**：完整的标签页管理。
- **`snapshot`**：获取 AI 优化过的页面结构快照（Accessibility Tree），这是 Agent "看懂"网页的关键。
- **`screenshot`** / **`pdf`**：截屏或保存 PDF。
- **`act`**：执行 UI 操作（点击、输入、按键、等待、滚动）。
- **`console`**：读取浏览器控制台日志。
- **`upload`** / **`dialog`**：处理文件上传弹窗和 JS Alert 弹窗。

### 3. 系统与执行 (System)
- **`exec`**：执行 Shell 命令（受控环境）。
- **`process`**：管理长运行进程（如启动开发服务器）。

### 4. 网络与数据 (Web & Data)
- **`web_search`**：进行 Google/Bing 搜索。
- **`web_fetch`**：轻量级抓取网页内容（不启动完整浏览器）。

### 5. 多媒体生成 (Media)
- **`tts`**：文本转语音（Text-to-Speech）。
- **`image`**：图像生成或视觉识别。
- **`canvas`**：绘图能力。

### 6. 会话与编排 (Orchestration)
- **`agents_list`** / **`sessions_spawn`**：管理多 Agent 协作与子任务分发。
- **`cron`**：设置定时任务。
- **`message`**：跨渠道发送消息。
- **`nodes`**：知识图谱/记忆节点管理。

### 7. 外部扩展 (Plugins)
Moltbot 支持大量第三方集成插件（Skills），例如：
- 1Password, Spotify, Linear, GitHub, Notion, Slack 等。

### 8. 安全与存储 (Security & Persistence)
- **文件权限 (System Access)**：
    - 支持 **Sandboxed** (Docker/受限目录) 和 **Host** (本机系统级) 两种运行模式。
    - 危险操作（如 `exec` 和 `browser`）可以通过 Policy 策略配置为仅限沙箱运行，或允许受控的本机访问。
- **持久化 (Persistence)**：
    - **Session**：对话历史存储为 JSON 文件（带文件锁）。
    - **Memory**：使用 `node:sqlite` + `sqlite-vec` 实现本地向量数据库。
    - **Media**：图片/文件自动存储在本地文件系统中。

> **Belldandy 现状对比**：目前 Belldandy 已实现了 **文件操作** (read/write)、**Web Fetch**、**Memory**、**浏览器自动化（基础版）**，并提供 **Safe Mode 的系统命令执行**（白名单 + 超时 + 风险阻断）。

---

## 📊 Moltbot vs Belldandy Agent 能力详细对比

### 对比总结

| 能力类别 | Moltbot | Belldandy | 差距 |
|---------|---------|-----------|------|
| **文件操作** | ✅ 完整 | ✅ 完整 | `list_files`, `apply_patch` (DSL) 已就绪 |
| **系统命令** | ✅ exec/process | ✅ exec/terminal | **Safe Mode** 保护 |
| **浏览器自动化** | ✅ 28+ actions | ✅ 核心闭环 | 支持快照/截图/操作/中继 |
| **网络请求** | ✅ search + fetch | ✅ search + fetch | 集成 Brave/SerpAPI |
| **记忆系统** | ✅ memory + nodes | ✅ memory | 缺少 `nodes` 图谱 |
| **多媒体** | ✅ tts/image/canvas | ✅ tts/image | 缺少 `canvas` |
| **会话编排** | ✅ 完整 | ❌ 未实现 | — |
| **渠道集成** | ✅ 4+ channels | ✅ 飞书 + Channel 接口 | 架构已就绪，可快速扩展 |
| **定时任务** | ✅ cron tool | ✅ heartbeat | 不同实现 |
| **插件系统** | ✅ 丰富 | ✅ 完整对标 | 13 种钩子 + HookRunner + 优先级 |
| **MCP 支持** | ✅ ACP 协议 | ✅ MCP 协议 | stdio/SSE 传输 + 工具桥接 |

---

### Moltbot Agent 工具完整清单

#### 1. 文件操作 (Coding Tools)

| 工具 | 说明 | Belldandy |
|------|------|-----------|
| `read` / `read_file_content` | 读取文件内容 | ✅ `file_read` |
| `write` / `write_file` | 写入文件 | ✅ `file_write` |
| `edit` | 编辑现有文件（多处替换） | ✅ `edit_file` |
| `list_files` | 列出目录结构 | ✅ `list_files` |
| `apply_patch` | 应用 Unified Diff 补丁 | ✅ `apply_patch_dsl` |

#### 2. 系统命令 (Execution)

| 工具 | 说明 | Belldandy |
|------|------|-----------|
| `exec` | 执行 Shell 命令（受控环境） | ✅ `run_command` (Safe) |
| `process` | 管理长运行进程（后台任务） | ✅ `process_manager` |

> ⚠️ **安全提示**：这两个工具允许 Agent 执行任意系统命令。Moltbot 通过 Docker 沙箱、执行审批机制、白名单等手段控制风险。

#### 3. 浏览器自动化 (Browser Control)

| Action | 说明 | Belldandy |
|--------|------|-----------|
| `status` | 检查浏览器状态 | ✅ `browser_status` |
| `start` / `stop` | 启动/关闭浏览器 | ✅ (自动/中继) |
| `tabs` / `open` / `focus` / `close` | 标签页管理 | ✅ `browser_manage_tab` |
| `snapshot` | AI 优化页面结构快照 | ✅ `browser_snapshot` |
| `screenshot` / `pdf` | 截屏/保存 PDF | ✅ `browser_screenshot` |
| `act` | 点击/输入/按键/滚动 | ✅ `browser_action` |

#### 4. 网络与数据 (Web)

| 工具 | 说明 | Belldandy |
|------|------|-----------|
| `web_search` | Google/Bing 搜索 | ✅ `web_search` |
| `web_fetch` | 轻量级网页抓取 | ✅ |

#### 5. 多媒体 (Media)

| 工具 | 说明 | Belldandy |
|------|------|-----------|
| `tts` | 文本转语音 | ✅ `text_to_speech` |
| `image` | 图像生成/视觉识别 | ✅ `image_generate` |
| `canvas` | 绘图能力 | ❌ |

#### 6. 会话与编排 (Orchestration)

| 工具 | 说明 | Belldandy |
|------|------|-----------|
| `agents_list` | 列出可用 Agent | ❌ |
| `sessions_list` | 列出会话 | ❌ |
| `sessions_spawn` | 创建子 Agent 任务 | ❌ |
| `cron` | 定时任务管理 | ⚠️ heartbeat |
| `message` | 跨渠道发送消息 | ❌ |

#### 7. 记忆与知识 (Memory & Nodes)

| 工具 | 说明 | Belldandy |
|------|------|-----------|
| `memory_search` | 向量+关键词检索 | ✅ |
| `memory_read` | 读取记忆文件 | ✅ |
| `memory_write` | 写入记忆 | ✅ |
| `nodes` | 知识图谱节点管理 | ❌ |

#### 8. 渠道特定工具

| 渠道 | Belldandy | 说明 |
|------|-----------|------|
| Slack | ⏳ 待实现 | Channel 接口已就绪 |
| Discord | ⏳ 待实现 | Channel 接口已就绪 |
| Telegram | ⏳ 待实现 | Channel 接口已就绪 |
| WhatsApp | ⏳ 待实现 | Channel 接口已就绪 |
| 飞书 | ✅ 已实现 | 完整实现 Channel 接口 |

---

### Belldandy 当前已实现

| 能力 | 工具/功能 |
|------|----------|
| **文件读取** | `file_read` |
| **文件写入** | `file_write` |
| **网页抓取** | `web_fetch`（含域名黑白名单、SSRF 防护） |
| **记忆检索** | `memory_search`（FTS5 + 向量混合检索） |
| **记忆读写** | `memory_read`, `memory_write` |
| **飞书渠道** | `FeishuChannel`（WebSocket 长连接） |
| **定时触发** | `Heartbeat Runner`（读取 HEARTBEAT.md） |
| **会话历史** | `ConversationStore`（内存 + TTL） |

---

### 🎯 推荐下一步优先级
 
 1. ~~**`list_files`** — 低风险，直接列目录，Agent 探索能力基础~~ ✅ 已完成
 2. ~~**`web_search`** — 中等风险，需对接搜索 API（Bing/Google/DuckDuckGo）~~ ✅ 已完成
 3. ~~**`exec` (沙箱版)** — 高风险，已实现 Consumer Safe Mode~~ ✅ 已完成 (含 Windows 支持)
 4. ~~**`browser` (基础版)** — 高复杂度，可先做 `navigate` + `screenshot`~~ ✅ 已完成
 5. **`logging` (日志系统)** — 文件日志 + 轮转 + Agent 日志工具（Phase 18）
 6. **`sessions_spawn` (子 Agent 编排)** — 赋予 Agent 团队作战能力（Phase 16）
 7. **`canvas` / `code_interpreter` (Stateful)** — 更高级的创造与计算能力

